#!/usr/bin/python
#################################################################################################
# Copyright (c) 2010, Lawrence Livermore National Security, LLC.  
# Produced at the Lawrence Livermore National Laboratory  
# Written by Todd Gamblin, tgamblin@llnl.gov.
# LLNL-CODE-417602
# All rights reserved.  
# 
# This file is part of Libra. For details, see http://github.com/tgamblin/libra.
# Please also read the LICENSE file for further information.
# 
# Redistribution and use in source and binary forms, with or without modification, are
# permitted provided that the following conditions are met:
# 
#  * Redistributions of source code must retain the above copyright notice, this list of
#    conditions and the disclaimer below.
#  * Redistributions in binary form must reproduce the above copyright notice, this list of
#    conditions and the disclaimer (as noted below) in the documentation and/or other materials
#    provided with the distribution.
#  * Neither the name of the LLNS/LLNL nor the names of its contributors may be used to endorse
#    or promote products derived from this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
# LAWRENCE LIVERMORE NATIONAL SECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#################################################################################################

from PyQt4.QtGui import *
from PyQt4.QtCore import *
import os, StringIO, re, effort, icons, collections


def flushCache():
    symtab = None

#
# Symbol information about a single (module, offset) pair from the symtab file.
#
class SymData:
    def __init__(self, file, line, fun, module, offset):
        self._undefined = "?" in (file, line, fun, module, offset)
        self.module = module
        self.file = file
        self.fun = fun

        if (self._undefined):
            self.offset = self.line = 0
        else:
            self.offset = int(offset, 0)
            self.line = int(line, 0)

    def undefined(self):
        return self._undefined


class Symtab:
    """Maintains a set of mappings from (module, offset) pairs to SymData.  Also allows for module aliases, so
       that we can look up modules by alternate names.  This is useful, e.g., if we didn't know the executable name
       at runtime and recorded 'unknown' or '' instead of the proper path to the executable.
    """
    def __init__(self, symfile):
        self._symtab  = {}    # mapping from (module, offset) to symbol data
        self._aliases = {}    # set of aliases for modules

        try:
            symfile = open(symfile, "r")
            mapping = re.compile(".*=>.*")
        
            for line in symfile:
                line = line.rstrip('\n')
          
                if mapping.match(line):
                    alias, module = map(str.strip, line.split("=>"))
                    self._aliases[alias] = module
    
                else:
                    data = SymData(*line.split("|"))
                    key = (data.module, data.offset)
                    self._symtab[key] = data

        except IOError:
            # Just ignore the IO Error.
            pass
        
    def get(self, key):
        module, offset = key
        if module in self._aliases:
            module = self._aliases[module]
        return self._symtab.get((module, offset))

    def __getitem__(self, key):
        key = self.get(key)
        if not key: raise KeyError(key)
        return key
        
    def __contains__(self, key):
        self.get(key) != None
        


symtab = None

#
# Loads symtab data generated by libra-build-viewer-data into
# module-wide map.
#
def loadSymtab(symfile="viewer-data/symtab"):
    global symtab
    if symtab: return
    symtab = Symtab(symfile)

def getSymbol(key):
  global symtab
  loadSymtab()
  return symtab.get(key)


def find(targetFile, root="viewer-data/src"):
    for subdirname in os.listdir(root):
        subdir = "%s/%s" % (root,subdirname)
        if os.path.isdir(subdir):
            for filename in os.listdir(subdir):
                if filename == targetFile:
                    file = "%s/%s" % (subdir, filename)
                    return file

class RegionHighlighter(QSyntaxHighlighter):
    def __init__(self, document):
        QSyntaxHighlighter.__init__(self, document)
        self.lineNum = 0
        self.start = 0
        self.end = 0

        self.format = QTextCharFormat()
        self.format.setBackground(QBrush(QColor(210, 210, 255)))
        
    def setLine(self, line):
        self.start = line
        self.end = line
        
    def setRange(self, start, end):
        self.start = start
        self.end = end
        
    def rehighlight(self):
        self.lineNum = 0
        QSyntaxHighlighter.rehighlight(self)

    def highlightBlock(self, text):
        self.lineNum += 1
        if self.start and self.end and self.lineNum in xrange(self.start, self.end+1):
            self.setFormat(0, len(text), self.format)
        
#
# Really simple source viewer with line numbers
#
class SourceViewer(QFrame):
    def __init__(self):
        QFrame.__init__(self)

        textLayout = QHBoxLayout()
        self.numbers = QPlainTextEdit()
        self.text =    QPlainTextEdit()
        self.lines = 0
        self.curLine  = 0

        # Read-only, monospace, no wrapping
        def setupCodeText(textEdit):
            textEdit.setReadOnly(True)
            textEdit.setLineWrapMode(QPlainTextEdit.NoWrap)
            format = QTextCharFormat()
            format.setFontFamily("monaco,luxi mono,courier,monospace")
            format.setFontPointSize(9)
            textEdit.setCurrentCharFormat(format)

            cursor = textEdit.textCursor()
            bfmt = QTextBlockFormat()
            bfmt.setTopMargin(0)
            bfmt.setBottomMargin(0)
            cursor.setBlockFormat(bfmt)
            textEdit.setTextCursor(cursor)

        setupCodeText(self.numbers)
        setupCodeText(self.text)

        # Line numbers view is very small and has no scroll bars.
        self.numbers.setFixedWidth(50)
        self.numbers.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.numbers.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)

        # Link scroll bars for line numbers and main text view.
        self.connect(self.text.verticalScrollBar(), SIGNAL("valueChanged(int)"),
                     self.numbers.verticalScrollBar().setValue)
        self.connect(self.numbers.verticalScrollBar(), SIGNAL("valueChanged(int)"),
                     self.text.verticalScrollBar().setValue)

        textLayout.addWidget(self.numbers)
        textLayout.addWidget(self.text)
        textLayout.setContentsMargins(0,0,0,0)
        textLayout.setSpacing(0)

        self.setLayout(textLayout)

    def loadFile(self, fullpath):
        if not fullpath:
            return
    
        file = open(fullpath)

        stringbuilder = StringIO.StringIO()
        linebuilder = StringIO.StringIO()

        linecount = 1
        for line in file:
            # TODO: maybe figure out a better way to get the highlighting to
            # span the width of the text editor, or use a better text editor.
            justified = line[:-1].ljust(200) + '\n'
            stringbuilder.write(justified)
            linebuilder.write("%5d \n" % linecount)
            linecount += 1

        self.curLine = 0
        self.lines = linecount - 1
        self.text.setPlainText(stringbuilder.getvalue())
        self.numbers.setPlainText(linebuilder.getvalue())

        stringbuilder.close()
        linebuilder.close()
        file.close()

    def setText(self, text):
        self.text.setPlainText(text)

    def goto(self, line):
        cursor = self.text.textCursor()
        distance = line - self.curLine

        if distance > 0:
            direction = QTextCursor.Down
        else:
            direction = QTextCursor.Up

        cursor.movePosition(direction, QTextCursor.MoveAnchor, abs(distance))
        self.text.setTextCursor(cursor)
        self.text.centerCursor()
        
    def __getattr__(self, attr):
        """Delegate to text frame in absence of attributes."""
        if hasattr(self.text, attr):
            return getattr(self.text, attr)
        else:
            raise AttributeError, self.__class__.__name__ + \
                  " has no attribute named " + attr


class CallpathViewer(QFrame):
    def __init__(self, callpathName, regionViewer=None, parent=None):
        QFrame.__init__(self, parent)
        self.path = []
        self.regionViewer = regionViewer

        layout = QVBoxLayout()
        layout.setContentsMargins(0,5,0,0)
        layout.setSpacing(3)

        nameLabel = QLabel(callpathName)        

        self.frameSelect = QComboBox()
        self.frameSelect.setSizeAdjustPolicy(QComboBox.AdjustToContents)
        self.connect(self.frameSelect, SIGNAL("currentIndexChanged(int)"), self.selectionChanged)

        self.topbar = QFrame(self)
        tlayout = QHBoxLayout()
        tlayout.setContentsMargins(0,0,0,0)
        tlayout.setSpacing(5)

        tlayout.addWidget(nameLabel)
        tlayout.addWidget(self.frameSelect)
        tlayout.addStretch()
        self.topbar.setLayout(tlayout)
        layout.addWidget(self.topbar)

        self.viewer = SourceViewer()
        layout.addWidget(self.viewer)
        self.setLayout(layout)

        self._highlighter = RegionHighlighter(self.viewer.document())
        self._highlighter.setRange(5, 20)

    def highlighter(self):
        return self._highlighter

    def addExtraWidget(self, widget):
        self.topbar.layout().addWidget(widget)
        
    def setCallpath(self, callpath):
        self.path = [effort.FrameViewWrapper(frame) for frame in callpath]
        self.frameSelect.clear()

        if not self.path:
            self.path.append(effort.FrameViewWrapper())
            self.frameSelect.addItem("unknown")
        else:
            for frame in self.path:
                self.frameSelect.addItem(frame.prettyLocation())

    def selectedFrame(self):
        index = self.frameSelect.currentIndex()
        if index in xrange(0, len(self.path)):
            return self.path[index]
        else:
            return effort.FrameViewWrapper()

    def setSelectedFrame(self, index):
        self.frameSelect.setCurrentIndex(index)

    def selectionChanged(self, index):
        file = self.selectedFrame().file()
        if not file:
            self.viewer.setText('Unknown file.')
        else:
            fullpath = find(file)
            if not fullpath:
                self.viewer.setText("Could not find file '%s'." % file)
            else:
                self.viewer.loadFile(fullpath)
                self.viewer.goto(self.selectedFrame().line())

                # If we're part of a region viewer, have it do the highlighting
                # otherwise do it ourselves since we only care about our own
                # callpath.
                if self.regionViewer:
                    self.regionViewer.rehighlight()
                else:
                    self._highlighter.setLine(self.selectedFrame().line())
                    self.rehighlight()

class RegionViewer(QFrame):
    def __init__(self, parent=None):
        QFrame.__init__(self, parent)
        self.region = None
        
        layout = QVBoxLayout()
        layout.setContentsMargins(0,0,0,0)
        layout.setSpacing(0)

        # Vertical splitter for start and end callpath viewers
        self.splitter = QSplitter(Qt.Vertical)
        self.startView = CallpathViewer("Start:", self)
        self.endView = CallpathViewer("End:", self)
        self.splitter.addWidget(self.startView)
        self.splitter.addWidget(self.endView)
        self.splitter.setChildrenCollapsible(False)

        # Add an extra button to the end viewer to hide it
        self.hideButton = QPushButton()
        self.hideButton.setFlat(True)
        self.hideButton.setIcon(icons.get("down_triangle"))
        self.hideButton.setText("Hide End")
        self.connect(self.hideButton, SIGNAL("clicked()"), self.toggleExpand)
        self.endView.addExtraWidget(self.hideButton)

        # Button to go below the splitter to show end when it's hidden
        self.showButton = QPushButton()
        self.showButton.setFlat(True)
        self.showButton.setIcon(icons.get("up_triangle"))
        self.showButton.setText("Show End")
        self.connect(self.showButton, SIGNAL("clicked()"), self.toggleExpand)
        self.showButton.setSizePolicy(QSizePolicy.Maximum, QSizePolicy.Maximum)
        showlayout = QHBoxLayout()
        showlayout.addStretch()
        showlayout.addWidget(self.showButton)

        # Put the main layout together here.
        layout.addWidget(self.splitter)
        layout.addLayout(showlayout)
        self.setLayout(layout)

        # Start things out with the end hidden.
        self.expanded = True
        self.toggleExpand()

    def toggleExpand(self):
        if self.expanded:
            self.showButton.show()
            self.endView.hide()
        else:
            self.showButton.hide()
            self.endView.show()

        self.expanded = not self.expanded
            
    def setRegion(self, region):
        self.region = region
        self.startView.setCallpath(region.start())
        self.endView.setCallpath(region.end())

    def setFrameIndex(self, index):
        self.startView.setSelectedFrame(index)
        self.endView.setSelectedFrame(index)

    def rehighlight(self):
        """ Quick hack for highlighting code regions in the same file.
            This won't work in all cases.
            TODO: Use ROSE for proper callpath intervals.
        """
        startFrame = self.startView.selectedFrame()
        endFrame = self.endView.selectedFrame()
        if startFrame.file() == endFrame.file():
            self.startView.highlighter().setRange(startFrame.line(), endFrame.line())
            self.endView.highlighter().setRange(startFrame.line(), endFrame.line())
        else:
            self.startView.highlighter().setLine(startFrame.line())
            self.endView.highlighter().setLine(endFrame.line())
    
        self.startView.highlighter().rehighlight()
        self.endView.highlighter().rehighlight()

    def sizeHint(self):
        return QSize(500, 900)
